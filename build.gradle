/*
 * Author : Frederick Bloom / hanasaki
 */

import org.gradle.api.artifacts.*

buildscript {
    repositories {
        mavenLocal()
        mavenCentral();
        // You may define additional repositories, or even remove "mavenCentral()".
        // Read more about repositories here:
        //   http://www.gradle.org/docs/current/userguide/dependency_management.html#sec:repositories

        maven { url "https://plugins.gradle.org/m2" }
    }
    dependencies {
        classpath "gradle.plugin.com.dorongold.plugins:task-tree:1.3"
        classpath("org.springframework.boot:spring-boot-gradle-plugin:2.0.3.RELEASE")
    }
    //    plugins {
    //        id "com.dorongold.task-tree" version "1.3"
    //    }
}

apply plugin: 'base' // To add "clean" task to the root project.
apply plugin: 'java'
apply plugin: "jacoco"
apply plugin: 'maven'
apply plugin: 'maven-publish'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'
//apply plugin: 'org.junit.platform.gradle.plugin'

task mergedJavadoc(type: Javadoc, description: 'Creates Javadoc from all the projects.') {
    title = 'All modules'
    destinationDir = new File(project.buildDir, 'merged-javadoc')

    // Note: The closures below are executed lazily.
    source {
        subprojects*.sourceSets*.main*.allSource
    }
    classpath.from {
        objects*.configurations*.compile*.copyRecursive({ !(it instanceof ProjectDependency); })*.resolve()
    }
}

//===========

ext {
    //    Properties props = new Properties()
    //    props.load(new FileInputStream("$project.rootDir/profile/"+"$environment"+".properties"))
    //    props.each { prop ->
    //        project.ext.set(prop.key, prop.value)
    //    }

    versionFile = new File(project.rootDir, 'version.properties')
    calculateVersionName = {
        def versionProps = readVersion()
        return "${versionProps['major']}.${versionProps['minor']}.${versionProps['patch']}-${versionProps['build']}"
    }
}

version=ext.calculateVersionName()
project.version=ext.calculateVersionName()

version = rootProject.version
group = rootProject.group
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
//    sourceCompatibility = java.src.version
//    targetCompatibility = java.target.version
//dependencies {
//    // Adding dependencies here will add the dependencies to each subproject.
//    compile "joda-time:joda-time:2.2"
//    testCompile "junit:junit:4.12"
//
//    // TODO: Add dependencies here ...
//    // You can read more about how to add dependency here:
//    //   http://www.gradle.org/docs/current/userguide/dependency_management.html#sec:how_to_declare_your_dependencies
//
//}

task allDeps(type: DependencyReportTask) {}
subprojects {
    task allDeps(type: DependencyReportTask) {}
    apply from: rootProject.file('common.gradle')
}

allprojects {
    project.version = rootProject.version
    //
    dependencies {
        // Adding dependencies here will add the dependencies to each subproject.
        compile "joda-time:joda-time:2.2"
        compile "org.slf4j:slf4j-api:1.7.25"
        //        compile("org.springframework.boot:spring-boot-starter-web")
        compile("org.springframework.boot:spring-boot-starter")

        testCompile('org.junit.jupiter:junit-jupiter-api:' + junitVersion)
        testRuntime("org.junit.jupiter:junit-jupiter-engine:5.2.0")

        // TODO: Add dependencies here ...
        // You can read more about how to add dependency here:
        //   http://www.gradle.org/docs/current/userguide/dependency_management.html#sec:how_to_declare_your_dependencies

    }
}

apply from: 'common.gradle'

//allprojects {
//    version = rootProject.version
//    group = rootProject.group
//    [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
//    //    sourceCompatibility = java.src.version
//    //    targetCompatibility = java.target.version
//}

Properties readVersion() {
    def version = new Properties()
    def stream
    try {
        stream = new FileInputStream(versionFile)
        version.load(stream)
    } catch (FileNotFoundException ignore) {
        println ignore.toString()
    } finally {
        if (stream != null) stream.close()
    }
    // safety defaults in case file is missing
    if(!version['major']) version['major'] = "1"
    if(!version['minor']) version['minor'] = "0"
    if(!version['patch']) version['minor'] = "0"
    if(!version['build']) version['build'] = "0"
    return version
}

void incrementVersionNumber() {
    def version = readVersion()

    // careful with the types, culprits: "9"++ = ":", "9" + 1 = "91"
    def build = version['build'] as int
    build++
    version['build'] = build.toString()
    def stream = new FileOutputStream(versionFile)
    try {
        version.store(stream, null)
    } finally {
        stream.close()
    }
}

gradle.taskGraph.whenReady {taskGraph ->
    //    if (taskGraph.hasTask(assembleDebug)) {  /* when run debug task */
    //        incrementVersionNumber()
    //    } else if (taskGraph.hasTask(assembleRelease)) { /* when run release task */
    //        incrementVersionNumber()
    //    } else
    //    if (!taskGraph.hasTask(release)) {
    //        //        rootProject.version='1.1.5'
    //        version='-SNAPSHOT'
    //    }
    if (taskGraph.hasTask(assemble)) {
        incrementVersionNumber()
    }
}


